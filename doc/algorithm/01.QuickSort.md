对于包含n个输的输入数组来说，快速排序是一种最坏情况的时间复杂度为```O(n^2)```的排序算法。虽然最坏情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，应为他的平均性能非常好，它的期望时间复杂度是```O(nlgn)```,而且```O(nlgn)```中隐含的常数因子非常小。另外，他还能够进行原址排序，甚至在虚存环境中也能很好的工作。
#### 快速排序描述
与归并排序一样，快速排序也使用了分治思想，下面是对一个典型子数组A[p..r]进行快速排序三步分治过程。
##### 分解：
数组A[p..r]被划分为两个（可能为空）的子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每一个元素都小于A[q]，而A[q]也小余A[q+1..r]中的每个元素，计算下标q也是划分过程的一部分。
##### 解决：
通过递归调用归并排序，对子数组A[p..q-1]和A[q+1..r]进行排序。
##### 合并：
因为子数组都是原址排序的，所以不需要合并操作：数组A[p..r]已有序
```java
QuickSort(A,p,r)
    if p < r
        q = PARTITION(A,p,r)
        QuickSort(A,p,q-1)
        QuickSort(A,q+1,r)
```
为了排序一个数组A的全部元素，初始调用QuickSort(A,1,A.length)
##### 数组的划分
算法的关键部分是PARTITION过程，它实现对A[p..r]的原址排序
```java
PARTITION(A,p,r)
    x=A[r]
    i=p-1
    for j=p to r-1
       if A[j] < x
         i=i+1
         swap A[i] with A[j]
    swap A[i+1] whit A[r]
    return i+1
```